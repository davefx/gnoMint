//  gnoMint: a graphical interface for managing a certification authority
//  Copyright (C) 2006 David Marín Carreño <davefx@gmail.com>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or   
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#include "ssl.h"

#include <openssl/rsa.h>
#include <openssl/dsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/bio.h>
#include <openssl/x509.h>
#include <openssl/conf.h>
#include <openssl/x509v3.h>
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include <libintl.h>
#define _(x) gettext(x)
#define N_(x) (x) gettext_noop(x)

#include <time.h>


int __add_ext(X509 *cert, int nid, char *value)
{
	X509_EXTENSION *ex;
	X509V3_CTX ctx;

	/* This sets the 'context' of the extensions. */
	/* No configuration database */

	X509V3_set_ctx_nodb(&ctx);

	/* Issuer and subject certs: both the target since it is self signed,
	 * no request and no CRL
	 */
	X509V3_set_ctx(&ctx, cert, cert, NULL, NULL, 0);

	ex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);

	if (!ex)
		return 0;

	X509_add_ext(cert,ex,-1);
	X509_EXTENSION_free(ex);

	return 1;
}


gboolean __mkcert (X509 *x, gchar *email_address, gchar *legal_id,
		 EVP_PKEY *private_ca_key, EVP_PKEY *public_client_key, 
		 int serial, int days)
{
	X509_NAME *name=NULL;
	
	X509_set_version (x, 2);
	ASN1_INTEGER_set (X509_get_serialNumber(x), serial);
	X509_gmtime_adj (X509_get_notBefore(x), 0);
	X509_gmtime_adj (X509_get_notAfter(x), (long) 60*60*24*days);
	X509_set_pubkey (x, public_client_key);

	name = X509_get_subject_name (x);

	/* This function creates and adds the entry, working out the
	 * correct string type and performing checks on its length.
	 * Normally we'd check the return value for errors...
	 */
	X509_NAME_add_entry_by_txt (name, "C",
				    MBSTRING_ASC, "ES", -1, -1, 0);
	if (legal_id)
		X509_NAME_add_entry_by_txt (name, "dnQualifier",
					    MBSTRING_ASC, legal_id, -1, -1, 0);

	X509_NAME_add_entry_by_txt (name, "emailAddress",
				    MBSTRING_ASC, email_address, -1, -1, 0);

	name = X509_get_issuer_name (x);

	/* This function creates and adds the entry, working out the
	 * correct string type and performing checks on its length.
	 * Normally we'd check the return value for errors...
	 */
	X509_NAME_add_entry_by_txt (name, "C",
				    MBSTRING_ASC, "ES", -1, -1, 0);
	X509_NAME_add_entry_by_txt (name, "CN",
				    MBSTRING_ASC, "ComuniCA", -1, -1, 0);


	/* Add various extensions: standard extensions */
	__add_ext (x, NID_basic_constraints, "critical,CA:TRUE");
	__add_ext (x, NID_key_usage, "critical,keyCertSign,cRLSign");

	__add_ext (x, NID_subject_key_identifier, "hash");

	/* Some Netscape specific extensions */
	__add_ext (x, NID_netscape_cert_type, "sslCA");

	__add_ext (x, NID_netscape_comment, "Generated by ComuniCA, by David Marin");

	
	if (! X509_sign (x, private_ca_key, EVP_md5()))
		goto err;

	if (X509_verify (x, private_ca_key) < 0)
		goto err;

	return TRUE;
err:
	return FALSE;
}


/* gchar * ssl_generate_certificate_rsa (gchar * email_address,  */
/* 					     gchar * legal_id,  */
/* 					     gchar * client_public_key) */
/* { */
/* 	BIO      * bio = NULL; */
/* 	RSA      * rsa_client_public_key = NULL; */
/* 	X509     * certificate = NULL; */
/* 	EVP_PKEY * evp_public_key = NULL; */
/* 	EVP_PKEY * evp_private_ca_key = NULL; */
	
/* 	char * result = NULL, * buffer = NULL; */
/* 	gint    len = 0; */

	
/* 	// Check if we have loaded keys */
/*  	if (! _keys_public_key) {  */
/*  		g_printerr ("Error: keys not loaded yet\n");  */
/*  		return NULL;  */
/*  	}  */


/* 	// Extract RSA structure from client_public_key string */

/* 	bio = BIO_new_mem_buf (client_public_key, -1); */
/* 	rsa_client_public_key = PEM_read_bio_RSAPublicKey (bio, NULL, NULL, NULL);						    */
/* 	BIO_set_close (bio, BIO_NOCLOSE); */
/* 	BIO_free (bio); */

/* 	if (! rsa_client_public_key) { */
/*  		g_printerr ("Not found rsa_client_public_key\n");  */
/* 		return NULL; */
/* 	} */

/* 	// Generate a new X509 certificate */
	
/* 	evp_private_ca_key = EVP_PKEY_new(); */
/* 	if (! EVP_PKEY_assign_RSA (evp_private_ca_key, _keys_private_key)) { */
/* 		RSA_free (rsa_client_public_key); */
/*  		g_printerr ("Error asigning CA private key\n");  */
/* 		return NULL; */
/* 	} */

/* 	evp_public_key = EVP_PKEY_new(); */
/* 	if (! EVP_PKEY_assign_RSA (evp_public_key, rsa_client_public_key)) { */
/* 		EVP_PKEY_free (evp_private_ca_key); */
/*  		g_printerr ("Error asigning client_public_key\n");  */
/* 		return NULL; */
/* 	} */

/* 	certificate = X509_new (); */

/* 	if (! __mkcert (certificate, email_address, legal_id,  */
/* 		      evp_private_ca_key, evp_public_key,  */
/* 		      ++ keys_cert_serial, 365)); */


/* 	// Convert new X509 certificate into a string */
	
/* 	bio = BIO_new (BIO_s_mem()); */

/* 	PEM_write_bio_X509 (bio, certificate); */

/* 	X509_free (certificate); */

/*         len = BIO_get_mem_data (bio, &buffer); */

/* 	result = g_new0(gchar, len+1); */
/* 	result = strncpy (result, (const char*) buffer, len); */
/*         BIO_free(bio); */
 
/* 	return result; */
/* } */


gint ssl_generate_rsa_keys (CaCreationData *creation_data,
			    gchar ** private_key,
			    gchar ** public_key)
{
	RSA * new_key_RSA = NULL;
	BIO * bio_public_key = NULL;
	BIO * bio_private_key = NULL;

	gint public_key_len = 0;
	gint private_key_len = 0;

	new_key_RSA = RSA_generate_key (creation_data->key_bitlength, 65537, NULL, NULL);
	if (! new_key_RSA) { // failure
		return -1;
	}	

	bio_public_key = BIO_new (BIO_s_mem());
	bio_private_key = BIO_new (BIO_s_mem());

	PEM_write_bio_RSAPublicKey (bio_public_key, new_key_RSA);
	public_key_len = BIO_ctrl_pending(bio_public_key);

	PEM_write_bio_RSAPrivateKey (bio_private_key, new_key_RSA, NULL, NULL, 0, NULL, NULL); 
	private_key_len = BIO_ctrl_pending(bio_private_key);	

	RSA_free (new_key_RSA);
	
	(* private_key) = g_new0 (gchar, private_key_len + 1);
	BIO_read (bio_private_key, (* private_key), private_key_len );		  

	(* public_key) = g_new0 (gchar, public_key_len + 1);
	BIO_read (bio_public_key, (* public_key), public_key_len );		  

	BIO_free (bio_private_key);
	BIO_free (bio_public_key);
	
	return 1;

}


gint ssl_generate_dsa_keys (CaCreationData *creation_data,
			    gchar ** private_key,
			    gchar ** public_key)
{
	DSA * new_key_DSA = NULL;
	BIO * bio_public_key = NULL;
	BIO * bio_private_key = NULL;

	gint public_key_len = 0;
	gint private_key_len = 0;

	new_key_DSA = DSA_generate_parameters(creation_data->key_bitlength, NULL, 0, NULL, NULL, NULL, NULL);		
	if (! new_key_DSA) { // failure
		return -1;
	}	

	DSA_generate_key (new_key_DSA);
	if (! new_key_DSA) { // failure
		return -1;
	}	

	bio_public_key = BIO_new (BIO_s_mem());
	bio_private_key = BIO_new (BIO_s_mem());

	PEM_write_bio_DSA_PUBKEY (bio_public_key, new_key_DSA);
	public_key_len = BIO_ctrl_pending(bio_public_key);

	PEM_write_bio_DSAPrivateKey (bio_private_key, new_key_DSA, NULL, NULL, 0, NULL, NULL); 
	private_key_len = BIO_ctrl_pending(bio_private_key);	

	DSA_free (new_key_DSA);
	
	(* private_key) = g_new0 (gchar, private_key_len + 1);
	BIO_read (bio_private_key, (* private_key), private_key_len );		  

	(* public_key) = g_new0 (gchar, public_key_len + 1);
	BIO_read (bio_public_key, (* public_key), public_key_len );		  

	BIO_free (bio_private_key);
	BIO_free (bio_public_key);
	
	return 1;

}

gint ssl_generate_self_signed_certificate (CaCreationData * creation_data, 
					   gchar * private_key,
					   gchar * public_key,
					   gchar ** cert)
{
	EVP_PKEY * signing_key = NULL;

	BIO * bio_public_key = NULL;
	BIO * bio_signing_private_key = NULL;
	BIO * bio_cert = NULL;

	X509     * certificate = NULL;
	X509_NAME *name=NULL;
	
	gint certificate_len = 0;

	glong days_before_expiration = 0;
	time_t tmp;
	struct tm expiration_time;

	// Calculate expiration
	tmp = time(NULL);
	gmtime_r (&tmp, &expiration_time);
	expiration_time.tm_mon = expiration_time.tm_mon + creation_data->key_months_before_expiration;
	expiration_time.tm_year = expiration_time.tm_year + (expiration_time.tm_mon / 12);
	expiration_time.tm_mon = expiration_time.tm_mon % 12;
	days_before_expiration = mktime(&expiration_time) - tmp;

 	// Extract RSA structure from public_key string 

	bio_public_key = BIO_new_mem_buf (public_key, -1);
	bio_signing_private_key = BIO_new_mem_buf (private_key, -1);

	signing_key = PEM_read_bio_PUBKEY (bio_public_key, NULL, NULL, NULL);
	PEM_read_bio_PrivateKey (bio_signing_private_key, &signing_key, NULL, NULL);

	BIO_free (bio_public_key);
	BIO_free (bio_signing_private_key);
	
	certificate = X509_new ();	

	// We are making a X509 v3 certificate (version = 2)
	X509_set_version (certificate, 2);

	ASN1_INTEGER_set (X509_get_serialNumber(certificate), 1);
	X509_gmtime_adj (X509_get_notBefore(certificate), 0);
	X509_gmtime_adj (X509_get_notAfter(certificate), days_before_expiration);
	X509_set_pubkey (certificate, signing_key);

	name = X509_get_subject_name (certificate);

	/* This function creates and adds the entry, working out the
	 * correct string type and performing checks on its length.
	 * Normally we'd check the return value for errors...
	 */
	if (creation_data->country)
		X509_NAME_add_entry_by_txt (name, "C",
					    MBSTRING_ASC, creation_data->country, -1, -1, 0);
	if (creation_data->state)
		X509_NAME_add_entry_by_txt (name, "ST",
					    MBSTRING_ASC, creation_data->state, -1, -1, 0);
	if (creation_data->city)
		X509_NAME_add_entry_by_txt (name, "L",
					    MBSTRING_ASC, creation_data->city, -1, -1, 0);
	if (creation_data->org)
		X509_NAME_add_entry_by_txt (name, "O",
					    MBSTRING_ASC, creation_data->org, -1, -1, 0);
	if (creation_data->ou)
		X509_NAME_add_entry_by_txt (name, "OU",
					    MBSTRING_ASC, creation_data->ou, -1, -1, 0);
	if (creation_data->cn)
		X509_NAME_add_entry_by_txt (name, "CN",
					    MBSTRING_ASC, creation_data->cn, -1, -1, 0);
	if (creation_data->emailAddress)
		X509_NAME_add_entry_by_txt (name, "emailAddress",
					    MBSTRING_ASC, creation_data->emailAddress, -1, -1, 0);

	name = X509_get_issuer_name (certificate);

	if (creation_data->country)
		X509_NAME_add_entry_by_txt (name, "C",
					    MBSTRING_ASC, creation_data->country, -1, -1, 0);
	if (creation_data->state)
		X509_NAME_add_entry_by_txt (name, "ST",
					    MBSTRING_ASC, creation_data->state, -1, -1, 0);
	if (creation_data->city)
		X509_NAME_add_entry_by_txt (name, "L",
					    MBSTRING_ASC, creation_data->city, -1, -1, 0);
	if (creation_data->org)
		X509_NAME_add_entry_by_txt (name, "O",
					    MBSTRING_ASC, creation_data->org, -1, -1, 0);
	if (creation_data->ou)
		X509_NAME_add_entry_by_txt (name, "OU",
					    MBSTRING_ASC, creation_data->ou, -1, -1, 0);
	if (creation_data->cn)
		X509_NAME_add_entry_by_txt (name, "CN",
					    MBSTRING_ASC, creation_data->cn, -1, -1, 0);
	if (creation_data->emailAddress)
		X509_NAME_add_entry_by_txt (name, "emailAddress",
					    MBSTRING_ASC, creation_data->emailAddress, -1, -1, 0);


	/* Add various extensions: standard extensions */
	__add_ext (certificate, NID_basic_constraints, "critical,CA:TRUE");
	__add_ext (certificate, NID_key_usage, "critical,keyCertSign,cRLSign");

	__add_ext (certificate, NID_subject_key_identifier, "hash");

	/* Some Netscape specific extensions */
	__add_ext (certificate, NID_netscape_cert_type, "sslCA");

	__add_ext (certificate, NID_netscape_comment, "Generated by gnoMint, by David Marin");

	
	if (! X509_sign (certificate, signing_key, EVP_md5()))
		return -1;

	if (X509_verify (certificate, signing_key) < 0)
		return -1;

	bio_cert = BIO_new (BIO_s_mem());
	PEM_write_bio_X509 (bio_cert, certificate);

	X509_free (certificate);

	certificate_len = BIO_ctrl_pending(bio_cert);	
	(* cert) = g_new0 (gchar, certificate_len + 1);
	BIO_read (bio_cert, (* cert), certificate_len);

	BIO_free (bio_cert);

	return 1;
}

